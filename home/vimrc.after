" Modeline and Comments {
"   vim: set foldmarker={,} foldlevel=0 foldmethod=marker
"
"   Vim cheat sheet
"   http://walking-without-crutches.heroku.com/image/images/vi-vim-cheat-sheet.png
"
"   shoutout
"   http://spf13.com/post/perfect-vimrc-vim-config-file
" }

" Environment {
  behave xterm

  set nocompatible
  set background=dark
" }

" General {
  set title

  set novisualbell
  set noerrorbells
  set t_vb=

  set mouse=a
  set mousehide
  set mousemodel=extend

  set encoding=utf-8
  try
    lang en_US
  catch
  endtry

  set nobackup
  set nowritebackup
  set noswapfile
  set history=1000
  set undolevels=5000

  set autoread
  set noautowrite
" }

" UI {
  set antialias
  set lazyredraw

  set ruler
  set number

  set cmdheight=3
  set showmode
  set showcmd
  set more

  set showmatch
  set ttyfast
" }

" Formatting {
  set fileformats=unix,dos,mac
  set fileformat=unix
" }

" Key (re)Mappings {
" }

" Functions {
" }

set incsearch
set hlsearch
set ignorecase
set smartcase

set autoindent
set smartindent
set copyindent

set tabstop=2
set shiftwidth=2
set softtabstop=2
set expandtab

set nowrap
set nolinebreak
set formatoptions=rolqn12
set formatprg=par\ -w70req
set whichwrap+=<,>,h,l

set backspace=eol,start,indent

set list
set listchars=tab:»·,trail:·,eol:¬,extends:#,nbsp:%,precedes:<

set statusline=%f\ 
set statusline+=%y "filetype
set statusline+=%{StatuslineLongLineWarning()}

"display warnings for wrong fileformats, file encodings, and trailing whitespace
set statusline+=%#warningmsg#
set statusline+=%{&fileformat!='unix'?'['.&fileformat.']':''}
set statusline+=%{&fileencoding!='utf-8'?'['.&fileencoding.']':''}
set statusline+=%{StatuslineTrailingSpaceWarning()}
set statusline+=%*
"
"display a warning if &et is wrong, or we have mixed-indenting
set statusline+=%#error#
set statusline+=%{StatuslineTabWarning()}
set statusline+=%{SyntasticStatuslineFlag()}
set statusline+=%{&paste?'[paste]':''}
set statusline+=%*


set statusline+=%r "read-only flag
set statusline+=%m "modified flag
set statusline+=%w
set statusline+=%{fugitive#statusline()}

set statusline+=%= "left/right separator
set statusline+=%{StatuslineCurrentHighlight()}
set statusline+=[%l/%L,%v\ %P]

set laststatus=2
set report=0
set complete=.,w,b,u,U,t,i,d
set wildmenu
set wildmode=list:longest
set wildignore=*.o,*.obj,.git,*.rbc,*.rbo,*.class,.svn,*.gem,*.zip,*.tar.gz,*.tar.bz2,*.rar,*.tar.xz,*/vendor/gems/*,*/vendor/cache/*,*/.bundle/*,*/.sass-cache/*,*.swp,*~,._*
set infercase

set diffopt=filler,vertical

set previewheight=30

let ruby_space_errors=1

map ` :set fu!<cr>
map <S-`> :ZoomWin<cr>

nnoremap <leader>ff :set fu!<cr>:ZoomWin<cr>

cnoremap w!! %!sudo tee > /dev/null %

" Markdown
nnoremap <leader>1 yypVr=
nnoremap <leader>2 yypVr-
nnoremap <silent> <leader>md :! open -a Marked %:p<cr><cr>

" rails
" nnoremap <leader>tv :CommandTFlush<cr><bar>:CommandT app/views<cr>
" nnoremap <leader>tc :CommandTFlush<cr><bar>:CommandT app/controllers<cr>
" nnoremap <leader>tm :CommandTFlush<cr><bar>:CommandT app/models<cr>
" nnoremap <leader>ta :CommandTFlush<cr><bar>:CommandT app/assets<cr>
" nnoremap <leader>tl :CommandTFlush<cr><bar>:CommandT lib<cr>
" nnoremap <leader>tp :CommandTFlush<cr><bar>:CommandT public<cr>
nnoremap <leader>tr :botright :vsplit config/routes.rb<cr>
nnoremap <leader>tg :botright :vsplit Gemfile<cr>

nnoremap <silent> <leader><space> :nohlsearch<cr>

" redo
nnoremap <leader>r <C-r>

" cd to directory of current buffer
nnoremap <leader>cd :cd %:p:h<cr>

" remove Windows ^M when encoding is borked
nnoremap <leader>m mmHmt:%s/<C-V><cr>//ge<cr>'tzt'm

nnoremap <leader>pp :setlocal paste!<cr>:set paste?<cr>
nnoremap <leader>.. :cd ..<cr>

" Spelling
noremap <leader>s! :setlocal spell!<cr>
noremap <leader>sn ]s
noremap <leader>sp [s
noremap <leader>sa zg
noremap <leader>s? z=

" Ruby
nnoremap <leader>rh :%s/\([^[:alnum:]:]\):\([[:alnum:]_]*\)\s\=\(\s*\)=>/\1\2:\3/g<cr>
vnoremap <leader>rh  :s/\([^[:alnum:]:]\):\([[:alnum:]_]*\)\s\=\(\s*\)=>/\1\2:\3/g<cr>

iabbrev xdate <c-r>=strftime("%m/%d/%Y")<cr>
iabbrev xtime <c-r>=strftime("%m/%d/%Y %H:%M:%S")<cr>

nnoremap / /\v
vnoremap / /\v

nnoremap <tab> %
vnoremap <tab> %

nnoremap ; :

nnoremap <leader>i :set list!<cr>
nnoremap <leader>s :%s/\s\+$//e<cr>:let @/=''<cr>
nnoremap <leader>a :Ack

" Re-hardwrap paragraph
vnoremap <leader>q gq
nnoremap <leader>q gqip

nnoremap <leader>v V`]

inoremap ii <ESC>

nnoremap <leader>w <C-w>v<C-w>l
nnoremap <leader>W <C-w>s<C-w>j
nnoremap <leader>= <C-w>=

nnoremap <C-h> <C-w>h
nnoremap <C-j> <C-w>j
nnoremap <C-k> <C-w>k
nnoremap <C-l> <C-w>l

"noremap <right> <ESC>:bn<RETURN>
"noremap <left> <ESC>:bp<RETURN>

:command! WQ wq
:command! Wq wq
:command! W w
:command! Q q

iab RuL ----+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8----+----9----+----0

vnoremap <leader>a<bar> :Tabularize /<bar><cr>
nnoremap <leader>a<bar> :Tabularize /<bar><cr>

vnoremap <leader>a<space> :Tabularize /<space><cr>
nnoremap <leader>a<space> :Tabularize /<space><cr>

vnoremap <leader>am2 :Tabularize /<bar>/l1c1l1c1r1c1<cr>
nnoremap <leader>am2 :Tabularize /<bar>/l1c1l1c1r1c1<cr>

vnoremap <leader>am3 :Tabularize /<bar>/l1c1l1c1l1c1r1c1<cr>
nnoremap <leader>am3 :Tabularize /<bar>/l1c1l1c1l1c1r1c1<cr>

map <Leader>n  :NERDTreeToggle<CR>
map <Leader>f :NERDTreeFind<CR>

" dbext
let g:dbext_default_window_use_horiz = 1

let g:dbext_default_window_use_bottom = 1
let g:dbext_default_buffer_lines = 30

let g:dbext_default_window_use_right = 1
let g:dbext_default_window_width = 80
let g:dbext_default_window_increment = 80

" auto-align cucumber tables using Tabularize
inoremap <silent> <Bar>   <Bar><Esc>:call <SID>align()<CR>a
function! s:align()
  let p = '^\s*|\s.*\s|\s*$'
  if exists(':Tabularize') && getline('.') =~# '^\s*|' && (getline(line('.')-1) =~# p || getline(line('.')+1) =~# p)
    let column = strlen(substitute(getline('.')[0:col('.')],'[^|]','','g'))
    let position = strlen(matchstr(getline('.')[0:col('.')],'.*|\s*\zs.*'))
    Tabularize/|/l1
    normal! 0
    call search(repeat('[^|]*|',column).'\s\{-\}'.repeat('.',position),'ce',line('.'))
  endif
endfunction

" auto-align = using Tabularize
" inoremap <silent> = =<Esc>:call <SID>ealign()<CR>a
" function! s:ealign()
"   let p = '^.*=\s.*$'
"   if exists(':Tabularize') && getline('.') =~# '^.*=' && (getline(line('.')-1) =~# p || getline(line('.')+1) =~# p)
"     let column = strlen(substitute(getline('.')[0:col('.')],'[^=]','','g'))
"     let position = strlen(matchstr(getline('.')[0:col('.')],'.*=\s*\zs.*'))
"     Tabularize/=/l1
"     normal! 0
"     call search(repeat('[^=]*=',column).'\s\{-\}'.repeat('.',position),'ce',line('.'))
"   endif
" endfunction

if has("autocmd")
  filetype on
  filetype indent on
  filetype plugin on

  autocmd! BufWritePost .vimrc.before source %
  autocmd! BufWritePost .vimrc.after  source %

  autocmd FileType make setlocal ts=8 sts=8 sw=8 noexpandtab
  autocmd FileType yaml setlocal ts=2 sts=2 sw=2 expandtab

  autocmd FileType sql  setlocal ts=4 sts=4 sw=4 expandtab

  autocmd BufWinLeave * call clearmatches()
  autocmd BufRead * call s:set_hidden()
  function s:set_hidden()
    if empty(&buftype) "most explorer plugins have buftype=nofile
        setlocal bufhidden=delete
    endif
  endfunction

  if v:version >= 700
    autocmd BufNewFile,BufRead *.txt setlocal spell spelllang=en
  endif
endif

set t_Co=256
colorscheme jellybeans

highlight ColorColumn guibg=#222222

" recalculate the trailing whitespace warning when idle, and after saving
autocmd cursorhold,bufwritepost * unlet! b:statusline_trailing_space_warning

function! StatuslineTrailingSpaceWarning()
  if !exists("b:statusline_trailing_space_warning")
    if search('\s\+$', 'nw') != 0
      let b:statusline_trailing_space_warning = '[whitespace]'
    else
      let b:statusline_trailing_space_warning = ''
    endif
  endif

  return b:statusline_trailing_space_warning
endfunction

"recalculate the tab warning flag when idle and after writing
autocmd cursorhold,bufwritepost * unlet! b:statusline_tab_warning

function! StatuslineTabWarning()
  if !exists("b:statusline_tab_warning")
    let tabs   = search('^\t', 'nw') != 0
    let spaces = search('^ ', 'nw')  != 0

    if tabs && spaces
      let b:statusline_tab_warning = '[mixed-indenting]'
    elseif (spaces && !&et) || (tabs && &et)
      let b:statusline_tab_warning = '[expandtab]'
    else
      let b:statusline_tab_warning = ''
    endif
  endif

  return b:statusline_tab_warning
endfunction

"recalculate the long line warnings when idle and after saving
autocmd cursorhold,bufwritepost * unlet! b:statusline_long_line_warning

function! StatuslineLongLineWarning()
  if !exists("b:statusline_long_line_warning")
    let long_line_lengths = s:LongLines()

    if len(long_line_lengths) > 0
      let b:statusline_long_line_warning = "[" .
        \ '#' . len(long_line_lengths) . "," .
        \ 'm' . s:Median(long_line_lengths) . "," .
        \ '$' . max(long_line_lengths) . "]"
    else
      let b:statusline_long_line_warning = ""
    endif
  endif

  return b:statusline_long_line_warning
endfunction

"return a list containing the lengths of the long lines in this buffer
function! s:LongLines()
  let threshold = (&textwidth ? &textwidth : 80)
  let spaces = repeat(" ", &ts)

  let long_line_lengths = []

  let i = 1
  while i <= line("$")
    let len = strlen(substitute(getline(i), '\t', spaces, 'g'))

    if len > threshold
      call add(long_line_lengths, len)
    endif

    let i += 1
  endwhile

  return long_line_lengths
endfunction

"find the median of the given array of numbers
function! s:Median(nums)
  let nums = sort(a:nums)
  let l = len(nums)

  if l % 2 == 1
    let i = (l - 1) / 2
    return nums[i]
  else
    return (nums[1/2] + nums[(1/2)-1]) / 2
  endif
endfunction

"return the syntax highlight group under the cursor
function! StatuslineCurrentHighlight()
  let name = synIDattr(synID(line('.'),col('.'),1),'name')
  if name == ''
    return ''
  else
    return '[' . name . ']'
  endif
endfunction

" ruby-conque
function! RunSingleConque(command)
  try
    exec "bdelete " . g:single_conque.buffer_name
  catch
  endtry
  let g:single_conque = conque_term#open(a:command, ['botright vsplit'])
endfunction
